// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file TypeLookupTypesTypeObject.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "TypeLookupTypes.h"
#include "TypeLookupTypesTypeObject.h"
#include <mutex>
#include <utility>
#include <sstream>
#include <fastrtps/rtps/common/SerializedPayload.h>
#include <fastrtps/utils/md5.h>
#include <fastrtps/types/TypeObjectFactory.h>
#include <fastrtps/types/TypeNamesGenerator.h>
#include <fastrtps/types/AnnotationParameterValue.h>
#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>

using namespace eprosima::fastrtps::rtps;

void registerTypeLookupTypesTypes()
{
    static std::once_flag once_flag;
    std::call_once(once_flag, []()
            {
                TypeObjectFactory *factory = TypeObjectFactory::get_instance();
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EquivalenceKind", eprosima::fastdds::dds::xtypes1_3::GetEquivalenceKindIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetEquivalenceKindObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EquivalenceKind", eprosima::fastdds::dds::xtypes1_3::GetEquivalenceKindIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetEquivalenceKindObject(false));





                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeKind", eprosima::fastdds::dds::xtypes1_3::GetTypeKindIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeKindObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeKind", eprosima::fastdds::dds::xtypes1_3::GetTypeKindIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeKindObject(false));






























                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentiferKind", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentiferKindIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentiferKindObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentiferKind", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentiferKindIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentiferKindObject(false));














                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MemberName", eprosima::fastdds::dds::xtypes1_3::GetMemberNameIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMemberNameObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MemberName", eprosima::fastdds::dds::xtypes1_3::GetMemberNameIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMemberNameObject(false));



                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::QualifiedTypeName", eprosima::fastdds::dds::xtypes1_3::GetQualifiedTypeNameIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetQualifiedTypeNameObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::QualifiedTypeName", eprosima::fastdds::dds::xtypes1_3::GetQualifiedTypeNameIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetQualifiedTypeNameObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PrimitiveTypeId", eprosima::fastdds::dds::xtypes1_3::GetPrimitiveTypeIdIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPrimitiveTypeIdObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PrimitiveTypeId", eprosima::fastdds::dds::xtypes1_3::GetPrimitiveTypeIdIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPrimitiveTypeIdObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EquivalenceHash", eprosima::fastdds::dds::xtypes1_3::GetEquivalenceHashIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetEquivalenceHashObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EquivalenceHash", eprosima::fastdds::dds::xtypes1_3::GetEquivalenceHashIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetEquivalenceHashObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::NameHash", eprosima::fastdds::dds::xtypes1_3::GetNameHashIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetNameHashObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::NameHash", eprosima::fastdds::dds::xtypes1_3::GetNameHashIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetNameHashObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::LBound", eprosima::fastdds::dds::xtypes1_3::GetLBoundIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetLBoundObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::LBound", eprosima::fastdds::dds::xtypes1_3::GetLBoundIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetLBoundObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::LBoundSeq", eprosima::fastdds::dds::xtypes1_3::GetLBoundSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetLBoundSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::LBoundSeq", eprosima::fastdds::dds::xtypes1_3::GetLBoundSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetLBoundSeqObject(false));



                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::SBound", eprosima::fastdds::dds::xtypes1_3::GetSBoundIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetSBoundObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::SBound", eprosima::fastdds::dds::xtypes1_3::GetSBoundIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetSBoundObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::SBoundSeq", eprosima::fastdds::dds::xtypes1_3::GetSBoundSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetSBoundSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::SBoundSeq", eprosima::fastdds::dds::xtypes1_3::GetSBoundSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetSBoundSeqObject(false));



                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeObjectHashId", eprosima::fastdds::dds::xtypes1_3::GetTypeObjectHashIdIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeObjectHashIdObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeObjectHashId", eprosima::fastdds::dds::xtypes1_3::GetTypeObjectHashIdIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeObjectHashIdObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MemberFlag", eprosima::fastdds::dds::xtypes1_3::GetMemberFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMemberFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MemberFlag", eprosima::fastdds::dds::xtypes1_3::GetMemberFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMemberFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CollectionElementFlag", eprosima::fastdds::dds::xtypes1_3::GetCollectionElementFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCollectionElementFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CollectionElementFlag", eprosima::fastdds::dds::xtypes1_3::GetCollectionElementFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCollectionElementFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StructMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetStructMemberFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetStructMemberFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StructMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetStructMemberFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetStructMemberFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetUnionMemberFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionMemberFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetUnionMemberFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionMemberFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionDiscriminatorFlag", eprosima::fastdds::dds::xtypes1_3::GetUnionDiscriminatorFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionDiscriminatorFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionDiscriminatorFlag", eprosima::fastdds::dds::xtypes1_3::GetUnionDiscriminatorFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionDiscriminatorFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EnumeratedLiteralFlag", eprosima::fastdds::dds::xtypes1_3::GetEnumeratedLiteralFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetEnumeratedLiteralFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EnumeratedLiteralFlag", eprosima::fastdds::dds::xtypes1_3::GetEnumeratedLiteralFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetEnumeratedLiteralFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AnnotationParameterFlag", eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AnnotationParameterFlag", eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AliasMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetAliasMemberFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAliasMemberFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AliasMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetAliasMemberFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAliasMemberFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitflagFlag", eprosima::fastdds::dds::xtypes1_3::GetBitflagFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetBitflagFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitflagFlag", eprosima::fastdds::dds::xtypes1_3::GetBitflagFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetBitflagFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitsetMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetBitsetMemberFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetBitsetMemberFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitsetMemberFlag", eprosima::fastdds::dds::xtypes1_3::GetBitsetMemberFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetBitsetMemberFlagObject(false));



                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeFlag", eprosima::fastdds::dds::xtypes1_3::GetTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeFlag", eprosima::fastdds::dds::xtypes1_3::GetTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StructTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetStructTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetStructTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StructTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetStructTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetStructTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetUnionTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetUnionTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CollectionTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetCollectionTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCollectionTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CollectionTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetCollectionTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCollectionTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AnnotationTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetAnnotationTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAnnotationTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AnnotationTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetAnnotationTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAnnotationTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AliasTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetAliasTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAliasTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AliasTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetAliasTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAliasTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EnumTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetEnumTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetEnumTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::EnumTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetEnumTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetEnumTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitmaskTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetBitmaskTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetBitmaskTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitmaskTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetBitmaskTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetBitmaskTypeFlagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitsetTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetBitsetTypeFlagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetBitsetTypeFlagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitsetTypeFlag", eprosima::fastdds::dds::xtypes1_3::GetBitsetTypeFlagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetBitsetTypeFlagObject(false));



                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StringSTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetStringSTypeDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetStringSTypeDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StringSTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetStringSTypeDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetStringSTypeDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StringLTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetStringLTypeDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetStringLTypeDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StringLTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetStringLTypeDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetStringLTypeDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetPlainCollectionHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainCollectionHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetPlainCollectionHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainCollectionHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainSequenceSElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceSElemDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceSElemDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainSequenceSElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceSElemDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceSElemDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainSequenceLElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceLElemDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceLElemDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainSequenceLElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceLElemDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainSequenceLElemDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainArraySElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainArraySElemDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainArraySElemDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainArraySElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainArraySElemDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainArraySElemDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainArrayLElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainArrayLElemDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainArrayLElemDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainArrayLElemDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainArrayLElemDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainArrayLElemDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainMapSTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainMapSTypeDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainMapSTypeDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainMapSTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainMapSTypeDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainMapSTypeDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainMapLTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainMapLTypeDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainMapLTypeDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::PlainMapLTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetPlainMapLTypeDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetPlainMapLTypeDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StronglyConnectedComponentId", eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentIdIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentIdObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StronglyConnectedComponentId", eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentIdIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentIdObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::ExtendedTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetExtendedTypeDefnIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetExtendedTypeDefnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::ExtendedTypeDefn", eprosima::fastdds::dds::xtypes1_3::GetExtendedTypeDefnIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetExtendedTypeDefnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MemberId", eprosima::fastdds::dds::xtypes1_3::GetMemberIdIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMemberIdObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MemberId", eprosima::fastdds::dds::xtypes1_3::GetMemberIdIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMemberIdObject(false));




                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::ExtendedAnnotationParameterValue", eprosima::fastdds::dds::xtypes1_3::GetExtendedAnnotationParameterValueIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetExtendedAnnotationParameterValueObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::ExtendedAnnotationParameterValue", eprosima::fastdds::dds::xtypes1_3::GetExtendedAnnotationParameterValueIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetExtendedAnnotationParameterValueObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AnnotationParameterValue", eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterValueIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterValueObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AnnotationParameterValue", eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterValueIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAnnotationParameterValueObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotationParameterSeq", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotationParameterSeq", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationParameterSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotation", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotation", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotationSeq", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedAnnotationSeq", eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedAnnotationSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedVerbatimAnnotation", eprosima::fastdds::dds::xtypes1_3::GetAppliedVerbatimAnnotationIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedVerbatimAnnotationObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedVerbatimAnnotation", eprosima::fastdds::dds::xtypes1_3::GetAppliedVerbatimAnnotationIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedVerbatimAnnotationObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedBuiltinMemberAnnotations", eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinMemberAnnotationsIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinMemberAnnotationsObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedBuiltinMemberAnnotations", eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinMemberAnnotationsIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinMemberAnnotationsObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonStructMember", eprosima::fastdds::dds::xtypes1_3::GetCommonStructMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonStructMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonStructMember", eprosima::fastdds::dds::xtypes1_3::GetCommonStructMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonStructMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteMemberDetail", eprosima::fastdds::dds::xtypes1_3::GetCompleteMemberDetailIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteMemberDetailObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteMemberDetail", eprosima::fastdds::dds::xtypes1_3::GetCompleteMemberDetailIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteMemberDetailObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalMemberDetail", eprosima::fastdds::dds::xtypes1_3::GetMinimalMemberDetailIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalMemberDetailObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalMemberDetail", eprosima::fastdds::dds::xtypes1_3::GetMinimalMemberDetailIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalMemberDetailObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructMember", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructMember", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructMemberSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructMember", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructMember", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructMemberSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedBuiltinTypeAnnotations", eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinTypeAnnotationsIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinTypeAnnotationsObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::AppliedBuiltinTypeAnnotations", eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinTypeAnnotationsIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetAppliedBuiltinTypeAnnotationsObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalTypeDetail", eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeDetailIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeDetailObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalTypeDetail", eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeDetailIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeDetailObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteTypeDetail", eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeDetailIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeDetailObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteTypeDetail", eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeDetailIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeDetailObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructType", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteStructType", eprosima::fastdds::dds::xtypes1_3::GetCompleteStructTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteStructTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructType", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalStructType", eprosima::fastdds::dds::xtypes1_3::GetMinimalStructTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalStructTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionCaseLabelSeq", eprosima::fastdds::dds::xtypes1_3::GetUnionCaseLabelSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionCaseLabelSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::UnionCaseLabelSeq", eprosima::fastdds::dds::xtypes1_3::GetUnionCaseLabelSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetUnionCaseLabelSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonUnionMember", eprosima::fastdds::dds::xtypes1_3::GetCommonUnionMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonUnionMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonUnionMember", eprosima::fastdds::dds::xtypes1_3::GetCommonUnionMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonUnionMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionMember", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionMember", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionMemberSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionMember", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionMember", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionMemberSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionMemberSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonDiscriminatorMember", eprosima::fastdds::dds::xtypes1_3::GetCommonDiscriminatorMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonDiscriminatorMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonDiscriminatorMember", eprosima::fastdds::dds::xtypes1_3::GetCommonDiscriminatorMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonDiscriminatorMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteDiscriminatorMember", eprosima::fastdds::dds::xtypes1_3::GetCompleteDiscriminatorMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteDiscriminatorMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteDiscriminatorMember", eprosima::fastdds::dds::xtypes1_3::GetCompleteDiscriminatorMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteDiscriminatorMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalDiscriminatorMember", eprosima::fastdds::dds::xtypes1_3::GetMinimalDiscriminatorMemberIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalDiscriminatorMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalDiscriminatorMember", eprosima::fastdds::dds::xtypes1_3::GetMinimalDiscriminatorMemberIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalDiscriminatorMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionType", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteUnionType", eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteUnionTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionType", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalUnionType", eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalUnionTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetCommonAnnotationParameterIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonAnnotationParameterObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetCommonAnnotationParameterIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonAnnotationParameterObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationParameterSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationParameterSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationParameterSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationParameter", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationParameterSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationParameterSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationParameterSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationType", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAnnotationType", eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAnnotationTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationType", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAnnotationType", eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAnnotationTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonAliasBody", eprosima::fastdds::dds::xtypes1_3::GetCommonAliasBodyIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonAliasBodyObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonAliasBody", eprosima::fastdds::dds::xtypes1_3::GetCommonAliasBodyIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonAliasBodyObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAliasBody", eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasBodyIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasBodyObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAliasBody", eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasBodyIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasBodyObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAliasBody", eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasBodyIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasBodyObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAliasBody", eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasBodyIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasBodyObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAliasHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAliasHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAliasHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAliasHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAliasType", eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteAliasType", eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteAliasTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAliasType", eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalAliasType", eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalAliasTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteElementDetail", eprosima::fastdds::dds::xtypes1_3::GetCompleteElementDetailIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteElementDetailObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteElementDetail", eprosima::fastdds::dds::xtypes1_3::GetCompleteElementDetailIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteElementDetailObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonCollectionElement", eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionElementIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionElementObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonCollectionElement", eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionElementIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionElementObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteCollectionElement", eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionElementIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionElementObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteCollectionElement", eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionElementIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionElementObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalCollectionElement", eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionElementIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionElementObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalCollectionElement", eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionElementIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionElementObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonCollectionHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteCollectionHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalCollectionHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalCollectionHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteSequenceType", eprosima::fastdds::dds::xtypes1_3::GetCompleteSequenceTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteSequenceTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteSequenceType", eprosima::fastdds::dds::xtypes1_3::GetCompleteSequenceTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteSequenceTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalSequenceType", eprosima::fastdds::dds::xtypes1_3::GetMinimalSequenceTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalSequenceTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalSequenceType", eprosima::fastdds::dds::xtypes1_3::GetMinimalSequenceTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalSequenceTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonArrayHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonArrayHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonArrayHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonArrayHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonArrayHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonArrayHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteArrayHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteArrayHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalArrayHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalArrayHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteArrayType", eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteArrayType", eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteArrayTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalArrayType", eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalArrayType", eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalArrayTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteMapType", eprosima::fastdds::dds::xtypes1_3::GetCompleteMapTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteMapTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteMapType", eprosima::fastdds::dds::xtypes1_3::GetCompleteMapTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteMapTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalMapType", eprosima::fastdds::dds::xtypes1_3::GetMinimalMapTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalMapTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalMapType", eprosima::fastdds::dds::xtypes1_3::GetMinimalMapTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalMapTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitBound", eprosima::fastdds::dds::xtypes1_3::GetBitBoundIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetBitBoundObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::BitBound", eprosima::fastdds::dds::xtypes1_3::GetBitBoundIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetBitBoundObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonEnumeratedLiteral", eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedLiteralIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedLiteralObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonEnumeratedLiteral", eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedLiteralIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedLiteralObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedLiteral", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedLiteral", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedLiteralSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedLiteralSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedLiteralSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedLiteral", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedLiteral", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedLiteralSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedLiteralSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedLiteralSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonEnumeratedHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonEnumeratedHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonEnumeratedHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedType", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteEnumeratedType", eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteEnumeratedTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedType", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalEnumeratedType", eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalEnumeratedTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonBitflag", eprosima::fastdds::dds::xtypes1_3::GetCommonBitflagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonBitflagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonBitflag", eprosima::fastdds::dds::xtypes1_3::GetCommonBitflagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonBitflagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitflag", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitflag", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitflagSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitflagSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitflagSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitflag", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitflag", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitflagSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitflagSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitflagSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonBitmaskHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonBitmaskHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonBitmaskHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonBitmaskHeader", eprosima::fastdds::dds::xtypes1_3::GetCommonBitmaskHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonBitmaskHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitmaskHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitmaskHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitmaskHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitmaskHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitmaskType", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitmaskType", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitmaskTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitmaskType", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitmaskType", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitmaskTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonBitfield", eprosima::fastdds::dds::xtypes1_3::GetCommonBitfieldIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonBitfieldObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CommonBitfield", eprosima::fastdds::dds::xtypes1_3::GetCommonBitfieldIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCommonBitfieldObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitfield", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitfield", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitfieldSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitfieldSeq", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitfieldSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitfield", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitfield", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitfieldSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitfieldSeq", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitfieldSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitsetHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitsetHeader", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitsetHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetHeaderIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitsetHeader", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetHeaderIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitsetType", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteBitsetType", eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteBitsetTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitsetType", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalBitsetType", eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalBitsetTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteExtendedType", eprosima::fastdds::dds::xtypes1_3::GetCompleteExtendedTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteExtendedTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteExtendedType", eprosima::fastdds::dds::xtypes1_3::GetCompleteExtendedTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteExtendedTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteTypeObject", eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeObjectIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeObjectObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::CompleteTypeObject", eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeObjectIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetCompleteTypeObjectObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalExtendedType", eprosima::fastdds::dds::xtypes1_3::GetMinimalExtendedTypeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalExtendedTypeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalExtendedType", eprosima::fastdds::dds::xtypes1_3::GetMinimalExtendedTypeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalExtendedTypeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalTypeObject", eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeObjectIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeObjectObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::MinimalTypeObject", eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeObjectIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetMinimalTypeObjectObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeObject", eprosima::fastdds::dds::xtypes1_3::GetTypeObjectIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeObjectObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeObject", eprosima::fastdds::dds::xtypes1_3::GetTypeObjectIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeObjectObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeObjectSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeObjectSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeObjectSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeObjectSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeObjectSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeObjectSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StronglyConnectedComponent", eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::StronglyConnectedComponent", eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetStronglyConnectedComponentObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierTypeObjectPair", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierTypeObjectPair", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierTypeObjectPairSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierTypeObjectPairSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierTypeObjectPairSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierPair", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierPair", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierPairSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierPairSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierPairSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentfierWithSize", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentfierWithSize", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentfierWithSizeSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentfierWithSizeSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentfierWithSizeSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierWithDependencies", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierWithDependencies", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierWithDependenciesSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierWithDependenciesSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeIdentifierWithDependenciesSeqObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeInformation", eprosima::fastdds::dds::xtypes1_3::GetTypeInformationIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeInformationObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeInformation", eprosima::fastdds::dds::xtypes1_3::GetTypeInformationIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeInformationObject(false));


                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeInformationSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeInformationSeqIdentifier(true),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeInformationSeqObject(true));
                factory->add_type_object("eprosima::fastdds::dds::xtypes1_3::TypeInformationSeq", eprosima::fastdds::dds::xtypes1_3::GetTypeInformationSeqIdentifier(false),
                        eprosima::fastdds::dds::xtypes1_3::GetTypeInformationSeqObject(false));






                factory->add_type_object("eprosima::fastrtps::rtps::SampleIdentity", eprosima::fastrtps::rtps::GetSampleIdentityIdentifier(true),
                        eprosima::fastrtps::rtps::GetSampleIdentityObject(true));
                factory->add_type_object("eprosima::fastrtps::rtps::SampleIdentity", eprosima::fastrtps::rtps::GetSampleIdentityIdentifier(false),
                        eprosima::fastrtps::rtps::GetSampleIdentityObject(false));



                factory->add_type_object("eprosima::fastrtps::types::ReturnCode_t", eprosima::fastrtps::types::GetReturnCode_tIdentifier(true),
                        eprosima::fastrtps::types::GetReturnCode_tObject(true));
                factory->add_type_object("eprosima::fastrtps::types::ReturnCode_t", eprosima::fastrtps::types::GetReturnCode_tIdentifier(false),
                        eprosima::fastrtps::types::GetReturnCode_tObject(false));




                factory->add_type_object("eprosima::fastdds::dds::rpc::UnknownOperation", eprosima::fastdds::dds::rpc::GetUnknownOperationIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetUnknownOperationObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::UnknownOperation", eprosima::fastdds::dds::rpc::GetUnknownOperationIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetUnknownOperationObject(false));


                factory->add_type_object("eprosima::fastdds::dds::rpc::UnknownException", eprosima::fastdds::dds::rpc::GetUnknownExceptionIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetUnknownExceptionObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::UnknownException", eprosima::fastdds::dds::rpc::GetUnknownExceptionIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetUnknownExceptionObject(false));


                factory->add_type_object("eprosima::fastdds::dds::rpc::UnusedMember", eprosima::fastdds::dds::rpc::GetUnusedMemberIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetUnusedMemberObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::UnusedMember", eprosima::fastdds::dds::rpc::GetUnusedMemberIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetUnusedMemberObject(false));


                factory->add_type_object("eprosima::fastdds::dds::rpc::RemoteExceptionCode_t", eprosima::fastdds::dds::rpc::GetRemoteExceptionCode_tIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetRemoteExceptionCode_tObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::RemoteExceptionCode_t", eprosima::fastdds::dds::rpc::GetRemoteExceptionCode_tIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetRemoteExceptionCode_tObject(false));


                factory->add_type_object("eprosima::fastdds::dds::rpc::InstanceName", eprosima::fastdds::dds::rpc::GetInstanceNameIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetInstanceNameObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::InstanceName", eprosima::fastdds::dds::rpc::GetInstanceNameIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetInstanceNameObject(false));


                factory->add_type_object("eprosima::fastdds::dds::rpc::RequestHeader", eprosima::fastdds::dds::rpc::GetRequestHeaderIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetRequestHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::RequestHeader", eprosima::fastdds::dds::rpc::GetRequestHeaderIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetRequestHeaderObject(false));


                factory->add_type_object("eprosima::fastdds::dds::rpc::ReplyHeader", eprosima::fastdds::dds::rpc::GetReplyHeaderIdentifier(true),
                        eprosima::fastdds::dds::rpc::GetReplyHeaderObject(true));
                factory->add_type_object("eprosima::fastdds::dds::rpc::ReplyHeader", eprosima::fastdds::dds::rpc::GetReplyHeaderIdentifier(false),
                        eprosima::fastdds::dds::rpc::GetReplyHeaderObject(false));






                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypes_In", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_InIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_InObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypes_In", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_InIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_InObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypes_Out", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_OutIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_OutObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypes_Out", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_OutIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_OutObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypes_Result", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_ResultIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_ResultObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypes_Result", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_ResultIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_ResultObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypeDependencies_In", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_InIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_InObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypeDependencies_In", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_InIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_InObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypeDependencies_Out", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_OutIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_OutObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypeDependencies_Out", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_OutIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_OutObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypeDependencies_Result", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_ResultIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_ResultObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_getTypeDependencies_Result", eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_ResultIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_ResultObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Call", eprosima::fastdds::dds::builtin::GetTypeLookup_CallIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_CallObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Call", eprosima::fastdds::dds::builtin::GetTypeLookup_CallIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_CallObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Request", eprosima::fastdds::dds::builtin::GetTypeLookup_RequestIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_RequestObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Request", eprosima::fastdds::dds::builtin::GetTypeLookup_RequestIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_RequestObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Return", eprosima::fastdds::dds::builtin::GetTypeLookup_ReturnIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_ReturnObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Return", eprosima::fastdds::dds::builtin::GetTypeLookup_ReturnIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_ReturnObject(false));


                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Reply", eprosima::fastdds::dds::builtin::GetTypeLookup_ReplyIdentifier(true),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_ReplyObject(true));
                factory->add_type_object("eprosima::fastdds::dds::builtin::TypeLookup_Reply", eprosima::fastdds::dds::builtin::GetTypeLookup_ReplyIdentifier(false),
                        eprosima::fastdds::dds::builtin::GetTypeLookup_ReplyObject(false));





            });
}

namespace eprosima {
    namespace fastrtps {
        namespace rtps {
        } // namespace rtps
        namespace types {
        } // namespace types
    } // namespace fastrtps
    namespace fastdds {
        namespace dds {
            namespace rpc {
                const TypeIdentifier* GetUnknownOperationIdentifier(bool complete)
                {
                    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnknownOperation", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetUnknownOperationObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("UnknownOperation", complete);
                }

                const TypeObject* GetUnknownOperationObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnknownOperation", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteUnknownOperationObject();
                    }
                    else
                    {
                        return GetMinimalUnknownOperationObject();
                    }
                }

                const TypeObject* GetMinimalUnknownOperationObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnknownOperation", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    // type_object->minimal().alias_type().header()... Is empty

                    // No flags apply
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false);


                    if (relatedType != nullptr)
                    {
                        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("UnknownOperation", "uint8_t");

                    TypeObjectFactory::get_instance()->add_type_object("UnknownOperation", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("UnknownOperation", false);
                }

                const TypeObject* GetCompleteUnknownOperationObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnknownOperation", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
                    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
                    type_object->complete().alias_type().header().detail().type_name("UnknownOperation");

                    // No flags apply
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    //type_object->complete().alias_type().body().common().ann_builtin()
                    //type_object->complete().alias_type().body().common().ann_custom()

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("uint8_t");


                    if (relatedType != nullptr)
                    {
                        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("UnknownOperation", "uint8_t");

                    TypeObjectFactory::get_instance()->add_type_object("UnknownOperation", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("UnknownOperation", true);
                }

                const TypeIdentifier* GetUnknownExceptionIdentifier(bool complete)
                {
                    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnknownException", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetUnknownExceptionObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("UnknownException", complete);
                }

                const TypeObject* GetUnknownExceptionObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnknownException", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteUnknownExceptionObject();
                    }
                    else
                    {
                        return GetMinimalUnknownExceptionObject();
                    }
                }

                const TypeObject* GetMinimalUnknownExceptionObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnknownException", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    // type_object->minimal().alias_type().header()... Is empty

                    // No flags apply
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false);


                    if (relatedType != nullptr)
                    {
                        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("UnknownException", "uint8_t");

                    TypeObjectFactory::get_instance()->add_type_object("UnknownException", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("UnknownException", false);
                }

                const TypeObject* GetCompleteUnknownExceptionObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnknownException", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
                    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
                    type_object->complete().alias_type().header().detail().type_name("UnknownException");

                    // No flags apply
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    //type_object->complete().alias_type().body().common().ann_builtin()
                    //type_object->complete().alias_type().body().common().ann_custom()

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("uint8_t");


                    if (relatedType != nullptr)
                    {
                        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("UnknownException", "uint8_t");

                    TypeObjectFactory::get_instance()->add_type_object("UnknownException", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("UnknownException", true);
                }

                const TypeIdentifier* GetUnusedMemberIdentifier(bool complete)
                {
                    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("UnusedMember", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetUnusedMemberObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("UnusedMember", complete);
                }

                const TypeObject* GetUnusedMemberObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnusedMember", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteUnusedMemberObject();
                    }
                    else
                    {
                        return GetMinimalUnusedMemberObject();
                    }
                }

                const TypeObject* GetMinimalUnusedMemberObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnusedMember", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    // type_object->minimal().alias_type().header()... Is empty

                    // No flags apply
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier("uint8_t", false);


                    if (relatedType != nullptr)
                    {
                        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("UnusedMember", "uint8_t");

                    TypeObjectFactory::get_instance()->add_type_object("UnusedMember", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("UnusedMember", false);
                }

                const TypeObject* GetCompleteUnusedMemberObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("UnusedMember", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
                    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
                    type_object->complete().alias_type().header().detail().type_name("UnusedMember");

                    // No flags apply
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    //type_object->complete().alias_type().body().common().ann_builtin()
                    //type_object->complete().alias_type().body().common().ann_custom()

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("uint8_t");


                    if (relatedType != nullptr)
                    {
                        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("UnusedMember", "uint8_t");

                    TypeObjectFactory::get_instance()->add_type_object("UnusedMember", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("UnusedMember", true);
                }

                const TypeIdentifier* GetRemoteExceptionCode_tIdentifier(bool complete)
                {
                    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RemoteExceptionCode_t", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetRemoteExceptionCode_tObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("RemoteExceptionCode_t", complete);
                }

                const TypeObject* GetRemoteExceptionCode_tObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RemoteExceptionCode_t", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteRemoteExceptionCode_tObject();
                    }
                    // else
                    return GetMinimalRemoteExceptionCode_tObject();
                }

                const TypeObject* GetMinimalRemoteExceptionCode_tObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RemoteExceptionCode_t", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_ENUM);

                    // No flags apply
                    //type_object->minimal().enumerated_type().enum_flags().IS_FINAL(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_APPENDABLE(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_MUTABLE(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_NESTED(false);
                    //type_object->minimal().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

                    type_object->minimal().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?

                    uint32_t value = 0;
                    MinimalEnumeratedLiteral mel_REMOTE_EX_OK;
                    mel_REMOTE_EX_OK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_REMOTE_EX_OK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_REMOTE_EX_OK.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_REMOTE_EX_OK.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_REMOTE_EX_OK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_REMOTE_EX_OK.common().flags().IS_KEY(false); // Doesn't apply
                    mel_REMOTE_EX_OK.common().flags().IS_DEFAULT(false);
                    mel_REMOTE_EX_OK.common().value(value++);
                    MD5 REMOTE_EX_OK_hash("REMOTE_EX_OK");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_REMOTE_EX_OK.detail().name_hash()[i] = REMOTE_EX_OK_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_REMOTE_EX_OK);

                    MinimalEnumeratedLiteral mel_REMOTE_EX_UNSUPPORTED;
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().IS_KEY(false); // Doesn't apply
                    mel_REMOTE_EX_UNSUPPORTED.common().flags().IS_DEFAULT(false);
                    mel_REMOTE_EX_UNSUPPORTED.common().value(value++);
                    MD5 REMOTE_EX_UNSUPPORTED_hash("REMOTE_EX_UNSUPPORTED");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_REMOTE_EX_UNSUPPORTED.detail().name_hash()[i] = REMOTE_EX_UNSUPPORTED_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_REMOTE_EX_UNSUPPORTED);

                    MinimalEnumeratedLiteral mel_REMOTE_EX_INVALID_ARGUMENT;
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_KEY(false); // Doesn't apply
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_DEFAULT(false);
                    mel_REMOTE_EX_INVALID_ARGUMENT.common().value(value++);
                    MD5 REMOTE_EX_INVALID_ARGUMENT_hash("REMOTE_EX_INVALID_ARGUMENT");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_REMOTE_EX_INVALID_ARGUMENT.detail().name_hash()[i] = REMOTE_EX_INVALID_ARGUMENT_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_REMOTE_EX_INVALID_ARGUMENT);

                    MinimalEnumeratedLiteral mel_REMOTE_EX_OUT_OF_RESOURCES;
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_KEY(false); // Doesn't apply
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_DEFAULT(false);
                    mel_REMOTE_EX_OUT_OF_RESOURCES.common().value(value++);
                    MD5 REMOTE_EX_OUT_OF_RESOURCES_hash("REMOTE_EX_OUT_OF_RESOURCES");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_REMOTE_EX_OUT_OF_RESOURCES.detail().name_hash()[i] = REMOTE_EX_OUT_OF_RESOURCES_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_REMOTE_EX_OUT_OF_RESOURCES);

                    MinimalEnumeratedLiteral mel_REMOTE_EX_UNKNOWN_OPERATION;
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_KEY(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_DEFAULT(false);
                    mel_REMOTE_EX_UNKNOWN_OPERATION.common().value(value++);
                    MD5 REMOTE_EX_UNKNOWN_OPERATION_hash("REMOTE_EX_UNKNOWN_OPERATION");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_REMOTE_EX_UNKNOWN_OPERATION.detail().name_hash()[i] = REMOTE_EX_UNKNOWN_OPERATION_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_REMOTE_EX_UNKNOWN_OPERATION);

                    MinimalEnumeratedLiteral mel_REMOTE_EX_UNKNOWN_EXCEPTION;
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_KEY(false); // Doesn't apply
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_DEFAULT(false);
                    mel_REMOTE_EX_UNKNOWN_EXCEPTION.common().value(value++);
                    MD5 REMOTE_EX_UNKNOWN_EXCEPTION_hash("REMOTE_EX_UNKNOWN_EXCEPTION");
                    for(int i = 0; i < 4; ++i)
                    {
                        mel_REMOTE_EX_UNKNOWN_EXCEPTION.detail().name_hash()[i] = REMOTE_EX_UNKNOWN_EXCEPTION_hash.digest[i];
                    }
                    type_object->minimal().enumerated_type().literal_seq().emplace_back(mel_REMOTE_EX_UNKNOWN_EXCEPTION);


                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().enumerated_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("RemoteExceptionCode_t", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("RemoteExceptionCode_t", false);
                }

                const TypeObject* GetCompleteRemoteExceptionCode_tObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RemoteExceptionCode_t", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_ENUM);

                    // No flags apply
                    //type_object->complete().enumerated_type().enum_flags().IS_FINAL(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_APPENDABLE(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_MUTABLE(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_NESTED(false);
                    //type_object->complete().enumerated_type().enum_flags().IS_AUTOID_HASH(false);

                    type_object->complete().enumerated_type().header().common().bit_bound(32); // TODO fixed by IDL, isn't?
                    type_object->complete().enumerated_type().header().detail().type_name("RemoteExceptionCode_t");

                    uint32_t value = 0;
                    CompleteEnumeratedLiteral cel_REMOTE_EX_OK;
                    cel_REMOTE_EX_OK.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_REMOTE_EX_OK.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_REMOTE_EX_OK.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_REMOTE_EX_OK.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_REMOTE_EX_OK.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_REMOTE_EX_OK.common().flags().IS_KEY(false); // Doesn't apply
                    cel_REMOTE_EX_OK.common().flags().IS_DEFAULT(false);
                    cel_REMOTE_EX_OK.common().value(value++);
                    cel_REMOTE_EX_OK.detail().name("REMOTE_EX_OK");

                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_REMOTE_EX_OK);

                    CompleteEnumeratedLiteral cel_REMOTE_EX_UNSUPPORTED;
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().IS_KEY(false); // Doesn't apply
                    cel_REMOTE_EX_UNSUPPORTED.common().flags().IS_DEFAULT(false);
                    cel_REMOTE_EX_UNSUPPORTED.common().value(value++);
                    cel_REMOTE_EX_UNSUPPORTED.detail().name("REMOTE_EX_UNSUPPORTED");

                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_REMOTE_EX_UNSUPPORTED);

                    CompleteEnumeratedLiteral cel_REMOTE_EX_INVALID_ARGUMENT;
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_KEY(false); // Doesn't apply
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().flags().IS_DEFAULT(false);
                    cel_REMOTE_EX_INVALID_ARGUMENT.common().value(value++);
                    cel_REMOTE_EX_INVALID_ARGUMENT.detail().name("REMOTE_EX_INVALID_ARGUMENT");

                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_REMOTE_EX_INVALID_ARGUMENT);

                    CompleteEnumeratedLiteral cel_REMOTE_EX_OUT_OF_RESOURCES;
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_KEY(false); // Doesn't apply
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().flags().IS_DEFAULT(false);
                    cel_REMOTE_EX_OUT_OF_RESOURCES.common().value(value++);
                    cel_REMOTE_EX_OUT_OF_RESOURCES.detail().name("REMOTE_EX_OUT_OF_RESOURCES");

                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_REMOTE_EX_OUT_OF_RESOURCES);

                    CompleteEnumeratedLiteral cel_REMOTE_EX_UNKNOWN_OPERATION;
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_KEY(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().flags().IS_DEFAULT(false);
                    cel_REMOTE_EX_UNKNOWN_OPERATION.common().value(value++);
                    cel_REMOTE_EX_UNKNOWN_OPERATION.detail().name("REMOTE_EX_UNKNOWN_OPERATION");

                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_REMOTE_EX_UNKNOWN_OPERATION);

                    CompleteEnumeratedLiteral cel_REMOTE_EX_UNKNOWN_EXCEPTION;
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().TRY_CONSTRUCT1(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().TRY_CONSTRUCT2(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_EXTERNAL(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_OPTIONAL(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_KEY(false); // Doesn't apply
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().flags().IS_DEFAULT(false);
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.common().value(value++);
                    cel_REMOTE_EX_UNKNOWN_EXCEPTION.detail().name("REMOTE_EX_UNKNOWN_EXCEPTION");

                    type_object->complete().enumerated_type().literal_seq().emplace_back(cel_REMOTE_EX_UNKNOWN_EXCEPTION);


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().enumerated_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("RemoteExceptionCode_t", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("RemoteExceptionCode_t", true);
                }

                const TypeIdentifier* GetInstanceNameIdentifier(bool complete)
                {
                    const TypeIdentifier* c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("InstanceName", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetInstanceNameObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("InstanceName", complete);
                }

                const TypeObject* GetInstanceNameObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InstanceName", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteInstanceNameObject();
                    }
                    else
                    {
                        return GetMinimalInstanceNameObject();
                    }
                }

                const TypeObject* GetMinimalInstanceNameObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InstanceName", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->minimal().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->minimal().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->minimal().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->minimal().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    // type_object->minimal().alias_type().header()... Is empty

                    // No flags apply
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->minimal().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->minimal().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier(TypeNamesGenerator::get_string_type_name(255, false), false);


                    if (relatedType != nullptr)
                    {
                        type_object->minimal().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("InstanceName", TypeNamesGenerator::get_string_type_name(255, false));

                    TypeObjectFactory::get_instance()->add_type_object("InstanceName", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InstanceName", false);
                }

                const TypeObject* GetCompleteInstanceNameObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("InstanceName", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_ALIAS);

                    // No flags apply
                    //type_object->complete().alias_type().alias_flags().IS_FINAL(false);
                    //type_object->complete().alias_type().alias_flags().IS_APPENDABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_MUTABLE(false);
                    //type_object->complete().alias_type().alias_flags().IS_NESTED(false);
                    //type_object->complete().alias_type().alias_flags().IS_AUTOID_HASH(false);

                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().placement("placement");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().language("language");
                    //type_object->complete().alias_type().header().detail().ann_builtin().verbatim().text("text");
                    //type_object->complete().alias_type().header().detail().ann_custom().push_back(...);
                    type_object->complete().alias_type().header().detail().type_name("InstanceName");

                    // No flags apply
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT1(false);
                    //type_object->complete().alias_type().body().common().related_flags().TRY_CONSTRUCT2(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_EXTERNAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_OPTIONAL(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_MUST_UNDERSTAND(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_KEY(false);
                    //type_object->complete().alias_type().body().common().related_flags().IS_DEFAULT(false);

                    //type_object->complete().alias_type().body().common().ann_builtin()
                    //type_object->complete().alias_type().body().common().ann_custom()

                    // Must be defined already, if don't, may be an recursive alias
                    const TypeIdentifier *relatedType = TypeObjectFactory::get_instance()->get_type_identifier_trying_complete(TypeNamesGenerator::get_string_type_name(255, false));


                    if (relatedType != nullptr)
                    {
                        type_object->complete().alias_type().body().common().related_type() = *relatedType; // Make a copy
                    }
                    else
                    {
                        // Cannot determine base type
                        delete type_object;
                        return nullptr;
                    }

                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().alias_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    // Don't add our TypeIdentifier but our alias
                    TypeObjectFactory::get_instance()->add_alias("InstanceName", TypeNamesGenerator::get_string_type_name(255, false));

                    TypeObjectFactory::get_instance()->add_type_object("InstanceName", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("InstanceName", true);
                }



                const TypeIdentifier* GetRequestHeaderIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("RequestHeader", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetRequestHeaderObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("RequestHeader", complete);
                }

                const TypeObject* GetRequestHeaderObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RequestHeader", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteRequestHeaderObject();
                    }
                    //else
                    return GetMinimalRequestHeaderObject();
                }

                const TypeObject* GetMinimalRequestHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RequestHeader", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_requestId;
                    mst_requestId.common().member_id(memberId++);
                    mst_requestId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_requestId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_requestId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_requestId.common().member_flags().IS_OPTIONAL(false);
                    mst_requestId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_requestId.common().member_flags().IS_KEY(false);
                    mst_requestId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_requestId.common().member_type_id(*eprosima::fastrtps::rtps::GetSampleIdentityIdentifier(false));

                    MD5 requestId_hash("requestId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_requestId.detail().name_hash()[i] = requestId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_requestId);

                    MinimalStructMember mst_instanceName;
                    mst_instanceName.common().member_id(memberId++);
                    mst_instanceName.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_instanceName.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_instanceName.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_instanceName.common().member_flags().IS_OPTIONAL(false);
                    mst_instanceName.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_instanceName.common().member_flags().IS_KEY(false);
                    mst_instanceName.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_instanceName.common().member_type_id(*eprosima::fastdds::dds::rpc::GetInstanceNameIdentifier(false));

                    MD5 instanceName_hash("instanceName");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_instanceName.detail().name_hash()[i] = instanceName_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_instanceName);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("RequestHeader", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("RequestHeader", false);
                }

                const TypeObject* GetCompleteRequestHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("RequestHeader", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_requestId;
                    cst_requestId.common().member_id(memberId++);
                    cst_requestId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_requestId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_requestId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_requestId.common().member_flags().IS_OPTIONAL(false);
                    cst_requestId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_requestId.common().member_flags().IS_KEY(false);
                    cst_requestId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_requestId.common().member_type_id(*eprosima::fastrtps::rtps::GetSampleIdentityIdentifier(true));

                    cst_requestId.detail().name("requestId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_requestId);

                    CompleteStructMember cst_instanceName;
                    cst_instanceName.common().member_id(memberId++);
                    cst_instanceName.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_instanceName.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_instanceName.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_instanceName.common().member_flags().IS_OPTIONAL(false);
                    cst_instanceName.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_instanceName.common().member_flags().IS_KEY(false);
                    cst_instanceName.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_instanceName.common().member_type_id(*eprosima::fastdds::dds::rpc::GetInstanceNameIdentifier(true));

                    cst_instanceName.detail().name("instanceName");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_instanceName);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("RequestHeader");
                    // TODO inheritance
                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetnestedIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("nested"));
                        {
                            AppliedAnnotationParameter annParam;
                            MD5 message_hash("value");
                            for(int i = 0; i < 4; ++i)
                            {
                                annParam.paramname_hash()[i] = message_hash.digest[i];
                            }
                            AnnotationParameterValue paramValue;
                            paramValue._d(TK_BOOLEAN);
                            paramValue.from_string("true");
                            annParam.value(paramValue);
                            ann.param_seq().push_back(annParam);
                        }

                        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
                    }


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("RequestHeader", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("RequestHeader", true);
                }



                const TypeIdentifier* GetReplyHeaderIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("ReplyHeader", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetReplyHeaderObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("ReplyHeader", complete);
                }

                const TypeObject* GetReplyHeaderObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ReplyHeader", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteReplyHeaderObject();
                    }
                    //else
                    return GetMinimalReplyHeaderObject();
                }

                const TypeObject* GetMinimalReplyHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ReplyHeader", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_relatedRequestId;
                    mst_relatedRequestId.common().member_id(memberId++);
                    mst_relatedRequestId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_relatedRequestId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_relatedRequestId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_relatedRequestId.common().member_flags().IS_OPTIONAL(false);
                    mst_relatedRequestId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_relatedRequestId.common().member_flags().IS_KEY(false);
                    mst_relatedRequestId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_relatedRequestId.common().member_type_id(*eprosima::fastrtps::rtps::GetSampleIdentityIdentifier(false));

                    MD5 relatedRequestId_hash("relatedRequestId");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_relatedRequestId.detail().name_hash()[i] = relatedRequestId_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_relatedRequestId);

                    MinimalStructMember mst_remoteEx;
                    mst_remoteEx.common().member_id(memberId++);
                    mst_remoteEx.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_remoteEx.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_remoteEx.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_remoteEx.common().member_flags().IS_OPTIONAL(false);
                    mst_remoteEx.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_remoteEx.common().member_flags().IS_KEY(false);
                    mst_remoteEx.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_remoteEx.common().member_type_id(*eprosima::fastdds::dds::rpc::GetRemoteExceptionCode_tIdentifier(false));

                    MD5 remoteEx_hash("remoteEx");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_remoteEx.detail().name_hash()[i] = remoteEx_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_remoteEx);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("ReplyHeader", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("ReplyHeader", false);
                }

                const TypeObject* GetCompleteReplyHeaderObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("ReplyHeader", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_relatedRequestId;
                    cst_relatedRequestId.common().member_id(memberId++);
                    cst_relatedRequestId.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_relatedRequestId.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_relatedRequestId.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_relatedRequestId.common().member_flags().IS_OPTIONAL(false);
                    cst_relatedRequestId.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_relatedRequestId.common().member_flags().IS_KEY(false);
                    cst_relatedRequestId.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_relatedRequestId.common().member_type_id(*eprosima::fastrtps::rtps::GetSampleIdentityIdentifier(true));

                    cst_relatedRequestId.detail().name("relatedRequestId");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_relatedRequestId);

                    CompleteStructMember cst_remoteEx;
                    cst_remoteEx.common().member_id(memberId++);
                    cst_remoteEx.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_remoteEx.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_remoteEx.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_remoteEx.common().member_flags().IS_OPTIONAL(false);
                    cst_remoteEx.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_remoteEx.common().member_flags().IS_KEY(false);
                    cst_remoteEx.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_remoteEx.common().member_type_id(*eprosima::fastdds::dds::rpc::GetRemoteExceptionCode_tIdentifier(true));

                    cst_remoteEx.detail().name("remoteEx");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_remoteEx);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("ReplyHeader");
                    // TODO inheritance
                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetnestedIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("nested"));
                        {
                            AppliedAnnotationParameter annParam;
                            MD5 message_hash("value");
                            for(int i = 0; i < 4; ++i)
                            {
                                annParam.paramname_hash()[i] = message_hash.digest[i];
                            }
                            AnnotationParameterValue paramValue;
                            paramValue._d(TK_BOOLEAN);
                            paramValue.from_string("true");
                            annParam.value(paramValue);
                            ann.param_seq().push_back(annParam);
                        }

                        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
                    }


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("ReplyHeader", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("ReplyHeader", true);
                }

            } // namespace rpc
        } // namespace dds
        namespace dds {
            namespace builtin {








                const TypeIdentifier* GetTypeLookup_getTypes_InIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypes_In", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_getTypes_InObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypes_In", complete);
                }

                const TypeObject* GetTypeLookup_getTypes_InObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_In", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_getTypes_InObject();
                    }
                    //else
                    return GetMinimalTypeLookup_getTypes_InObject();
                }

                const TypeObject* GetMinimalTypeLookup_getTypes_InObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_In", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_type_ids;
                    mst_type_ids.common().member_id(memberId++);
                    mst_type_ids.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_type_ids.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_type_ids.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_type_ids.common().member_flags().IS_OPTIONAL(false);
                    mst_type_ids.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_type_ids.common().member_flags().IS_KEY(false);
                    mst_type_ids.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_type_ids.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", 100, false));

                    MD5 type_ids_hash("type_ids");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_type_ids.detail().name_hash()[i] = type_ids_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_type_ids);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypes_In", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_In", false);
                }

                const TypeObject* GetCompleteTypeLookup_getTypes_InObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_In", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_type_ids;
                    cst_type_ids.common().member_id(memberId++);
                    cst_type_ids.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_type_ids.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_type_ids.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_type_ids.common().member_flags().IS_OPTIONAL(false);
                    cst_type_ids.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_type_ids.common().member_flags().IS_KEY(false);
                    cst_type_ids.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_type_ids.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", 100, true));

                    cst_type_ids.detail().name("type_ids");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_type_ids);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("TypeLookup_getTypes_In");
                    // TODO inheritance
                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetextensibilityIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("extensibility"));
                        {
                            AppliedAnnotationParameter annParam;
                            MD5 message_hash("value");
                            for(int i = 0; i < 4; ++i)
                            {
                                annParam.paramname_hash()[i] = message_hash.digest[i];
                            }
                            AnnotationParameterValue paramValue;
                            paramValue._d(EK_MINIMAL);
                            paramValue.from_string("2");
                            annParam.value(paramValue);
                            ann.param_seq().push_back(annParam);
                        }

                        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
                    }


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypes_In", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_In", true);
                }





                const TypeIdentifier* GetTypeLookup_getTypes_OutIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypes_Out", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_getTypes_OutObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypes_Out", complete);
                }

                const TypeObject* GetTypeLookup_getTypes_OutObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Out", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_getTypes_OutObject();
                    }
                    //else
                    return GetMinimalTypeLookup_getTypes_OutObject();
                }

                const TypeObject* GetMinimalTypeLookup_getTypes_OutObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Out", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_types;
                    mst_types.common().member_id(memberId++);
                    mst_types.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_types.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_types.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_types.common().member_flags().IS_OPTIONAL(false);
                    mst_types.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_types.common().member_flags().IS_KEY(false);
                    mst_types.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_types.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierTypeObjectPair", 100, false));

                    MD5 types_hash("types");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_types.detail().name_hash()[i] = types_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_types);

                    MinimalStructMember mst_complete_to_minimal;
                    mst_complete_to_minimal.common().member_id(memberId++);
                    mst_complete_to_minimal.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_complete_to_minimal.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_complete_to_minimal.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_complete_to_minimal.common().member_flags().IS_OPTIONAL(false);
                    mst_complete_to_minimal.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_complete_to_minimal.common().member_flags().IS_KEY(false);
                    mst_complete_to_minimal.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_complete_to_minimal.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierPair", 100, false));

                    MD5 complete_to_minimal_hash("complete_to_minimal");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_complete_to_minimal.detail().name_hash()[i] = complete_to_minimal_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_complete_to_minimal);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypes_Out", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Out", false);
                }

                const TypeObject* GetCompleteTypeLookup_getTypes_OutObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Out", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_types;
                    cst_types.common().member_id(memberId++);
                    cst_types.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_types.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_types.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_types.common().member_flags().IS_OPTIONAL(false);
                    cst_types.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_types.common().member_flags().IS_KEY(false);
                    cst_types.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_types.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierTypeObjectPair", 100, true));

                    cst_types.detail().name("types");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_types);

                    CompleteStructMember cst_complete_to_minimal;
                    cst_complete_to_minimal.common().member_id(memberId++);
                    cst_complete_to_minimal.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_complete_to_minimal.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_complete_to_minimal.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_complete_to_minimal.common().member_flags().IS_OPTIONAL(false);
                    cst_complete_to_minimal.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_complete_to_minimal.common().member_flags().IS_KEY(false);
                    cst_complete_to_minimal.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_complete_to_minimal.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifierPair", 100, true));

                    cst_complete_to_minimal.detail().name("complete_to_minimal");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_complete_to_minimal);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("TypeLookup_getTypes_Out");
                    // TODO inheritance
                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetextensibilityIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("extensibility"));
                        {
                            AppliedAnnotationParameter annParam;
                            MD5 message_hash("value");
                            for(int i = 0; i < 4; ++i)
                            {
                                annParam.paramname_hash()[i] = message_hash.digest[i];
                            }
                            AnnotationParameterValue paramValue;
                            paramValue._d(EK_MINIMAL);
                            paramValue.from_string("2");
                            annParam.value(paramValue);
                            ann.param_seq().push_back(annParam);
                        }

                        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
                    }


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypes_Out", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Out", true);
                }



                const TypeIdentifier* GetTypeLookup_getTypes_ResultIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypes_Result", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_getTypes_ResultObject(complete);
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypes_Result", complete);
                }

                const TypeObject* GetTypeLookup_getTypes_ResultObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Result", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_getTypes_ResultObject();
                    }
                    // else
                    return GetMinimalTypeLookup_getTypes_ResultObject();
                }

                const TypeObject* GetMinimalTypeLookup_getTypes_ResultObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Result", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_UNION);

                    type_object->minimal().union_type().union_flags().IS_FINAL(false);
                    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
                    type_object->minimal().union_type().union_flags().IS_NESTED(false);
                    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    MinimalUnionMember mst_result;
                    mst_result.common().member_id(memberId++);
                    mst_result.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_result.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_result.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_result.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_result.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_result.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_result.common().member_flags().IS_DEFAULT(false);
                    mst_result.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_OutIdentifier(false));

                    mst_result.common().label_seq().emplace_back(ReturnCode_t::RETCODE_OK);

                    MD5 result_hash("result");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_result.detail().name_hash()[i] = result_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_result);


                    // Header
                    //type_object->minimal().union_type().header().detail()... // Empty

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypes_Result", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Result", false);
                }

                const TypeObject* GetCompleteTypeLookup_getTypes_ResultObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Result", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_UNION);

                    type_object->complete().union_type().union_flags().IS_FINAL(false);
                    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
                    type_object->complete().union_type().union_flags().IS_NESTED(false);
                    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    CompleteUnionMember cst_result;
                    cst_result.common().member_id(memberId++);
                    cst_result.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_result.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_result.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_result.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_result.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_result.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_result.common().member_flags().IS_DEFAULT(false);
                    cst_result.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_OutIdentifier(true));
                    cst_result.common().label_seq().emplace_back(ReturnCode_t::RETCODE_OK);


                    cst_result.detail().name("result");

                    type_object->complete().union_type().member_seq().emplace_back(cst_result);


                    // Header
                    type_object->complete().union_type().header().detail().type_name("TypeLookup_getTypes_Result");

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypes_Result", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypes_Result", true);
                }





                const TypeIdentifier* GetTypeLookup_getTypeDependencies_InIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypeDependencies_In", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_getTypeDependencies_InObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypeDependencies_In", complete);
                }

                const TypeObject* GetTypeLookup_getTypeDependencies_InObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_In", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_getTypeDependencies_InObject();
                    }
                    //else
                    return GetMinimalTypeLookup_getTypeDependencies_InObject();
                }

                const TypeObject* GetMinimalTypeLookup_getTypeDependencies_InObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_In", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_type_ids;
                    mst_type_ids.common().member_id(memberId++);
                    mst_type_ids.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_type_ids.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_type_ids.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_type_ids.common().member_flags().IS_OPTIONAL(false);
                    mst_type_ids.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_type_ids.common().member_flags().IS_KEY(false);
                    mst_type_ids.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_type_ids.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", 100, false));

                    MD5 type_ids_hash("type_ids");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_type_ids.detail().name_hash()[i] = type_ids_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_type_ids);

                    MinimalStructMember mst_continuation_point;
                    mst_continuation_point.common().member_id(memberId++);
                    mst_continuation_point.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_continuation_point.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_continuation_point.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_continuation_point.common().member_flags().IS_OPTIONAL(false);
                    mst_continuation_point.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_continuation_point.common().member_flags().IS_KEY(false);
                    mst_continuation_point.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_continuation_point.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 32, false));

                    MD5 continuation_point_hash("continuation_point");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_continuation_point.detail().name_hash()[i] = continuation_point_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_continuation_point);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypeDependencies_In", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_In", false);
                }

                const TypeObject* GetCompleteTypeLookup_getTypeDependencies_InObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_In", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_type_ids;
                    cst_type_ids.common().member_id(memberId++);
                    cst_type_ids.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_type_ids.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_type_ids.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_type_ids.common().member_flags().IS_OPTIONAL(false);
                    cst_type_ids.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_type_ids.common().member_flags().IS_KEY(false);
                    cst_type_ids.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_type_ids.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentifier", 100, true));

                    cst_type_ids.detail().name("type_ids");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_type_ids);

                    CompleteStructMember cst_continuation_point;
                    cst_continuation_point.common().member_id(memberId++);
                    cst_continuation_point.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_continuation_point.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_continuation_point.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_continuation_point.common().member_flags().IS_OPTIONAL(false);
                    cst_continuation_point.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_continuation_point.common().member_flags().IS_KEY(false);
                    cst_continuation_point.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_continuation_point.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 32, true));

                    cst_continuation_point.detail().name("continuation_point");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_continuation_point);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("TypeLookup_getTypeDependencies_In");
                    // TODO inheritance
                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetextensibilityIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("extensibility"));
                        {
                            AppliedAnnotationParameter annParam;
                            MD5 message_hash("value");
                            for(int i = 0; i < 4; ++i)
                            {
                                annParam.paramname_hash()[i] = message_hash.digest[i];
                            }
                            AnnotationParameterValue paramValue;
                            paramValue._d(EK_MINIMAL);
                            paramValue.from_string("2");
                            annParam.value(paramValue);
                            ann.param_seq().push_back(annParam);
                        }

                        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
                    }


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypeDependencies_In", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_In", true);
                }





                const TypeIdentifier* GetTypeLookup_getTypeDependencies_OutIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypeDependencies_Out", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_getTypeDependencies_OutObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypeDependencies_Out", complete);
                }

                const TypeObject* GetTypeLookup_getTypeDependencies_OutObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Out", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_getTypeDependencies_OutObject();
                    }
                    //else
                    return GetMinimalTypeLookup_getTypeDependencies_OutObject();
                }

                const TypeObject* GetMinimalTypeLookup_getTypeDependencies_OutObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Out", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_dependent_typeids;
                    mst_dependent_typeids.common().member_id(memberId++);
                    mst_dependent_typeids.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_dependent_typeids.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_dependent_typeids.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_dependent_typeids.common().member_flags().IS_OPTIONAL(false);
                    mst_dependent_typeids.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_dependent_typeids.common().member_flags().IS_KEY(false);
                    mst_dependent_typeids.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_dependent_typeids.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentfierWithSize", 100, false));

                    MD5 dependent_typeids_hash("dependent_typeids");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_dependent_typeids.detail().name_hash()[i] = dependent_typeids_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_dependent_typeids);

                    MinimalStructMember mst_continuation_point;
                    mst_continuation_point.common().member_id(memberId++);
                    mst_continuation_point.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_continuation_point.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_continuation_point.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_continuation_point.common().member_flags().IS_OPTIONAL(false);
                    mst_continuation_point.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_continuation_point.common().member_flags().IS_KEY(false);
                    mst_continuation_point.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_continuation_point.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 32, false));

                    MD5 continuation_point_hash("continuation_point");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_continuation_point.detail().name_hash()[i] = continuation_point_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_continuation_point);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypeDependencies_Out", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Out", false);
                }

                const TypeObject* GetCompleteTypeLookup_getTypeDependencies_OutObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Out", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_dependent_typeids;
                    cst_dependent_typeids.common().member_id(memberId++);
                    cst_dependent_typeids.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_dependent_typeids.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_dependent_typeids.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_dependent_typeids.common().member_flags().IS_OPTIONAL(false);
                    cst_dependent_typeids.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_dependent_typeids.common().member_flags().IS_KEY(false);
                    cst_dependent_typeids.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_dependent_typeids.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("eprosima::fastdds::dds::xtypes1_3::TypeIdentfierWithSize", 100, true));

                    cst_dependent_typeids.detail().name("dependent_typeids");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_dependent_typeids);

                    CompleteStructMember cst_continuation_point;
                    cst_continuation_point.common().member_id(memberId++);
                    cst_continuation_point.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_continuation_point.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_continuation_point.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_continuation_point.common().member_flags().IS_OPTIONAL(false);
                    cst_continuation_point.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_continuation_point.common().member_flags().IS_KEY(false);
                    cst_continuation_point.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_continuation_point.common().member_type_id(*TypeObjectFactory::get_instance()->get_sequence_identifier("uint8_t", 32, true));

                    cst_continuation_point.detail().name("continuation_point");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_continuation_point);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("TypeLookup_getTypeDependencies_Out");
                    // TODO inheritance
                    {
                        AppliedAnnotation ann;
                        //ann.annotation_typeid(GetextensibilityIdentifier(true));
                        ann.annotation_typeid(*TypeObjectFactory::get_instance()->get_type_identifier_trying_complete("extensibility"));
                        {
                            AppliedAnnotationParameter annParam;
                            MD5 message_hash("value");
                            for(int i = 0; i < 4; ++i)
                            {
                                annParam.paramname_hash()[i] = message_hash.digest[i];
                            }
                            AnnotationParameterValue paramValue;
                            paramValue._d(EK_MINIMAL);
                            paramValue.from_string("2");
                            annParam.value(paramValue);
                            ann.param_seq().push_back(annParam);
                        }

                        type_object->complete().struct_type().header().detail().ann_custom().push_back(ann);
                    }


                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypeDependencies_Out", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Out", true);
                }



                const TypeIdentifier* GetTypeLookup_getTypeDependencies_ResultIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypeDependencies_Result", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_getTypeDependencies_ResultObject(complete);
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_getTypeDependencies_Result", complete);
                }

                const TypeObject* GetTypeLookup_getTypeDependencies_ResultObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Result", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_getTypeDependencies_ResultObject();
                    }
                    // else
                    return GetMinimalTypeLookup_getTypeDependencies_ResultObject();
                }

                const TypeObject* GetMinimalTypeLookup_getTypeDependencies_ResultObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Result", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_UNION);

                    type_object->minimal().union_type().union_flags().IS_FINAL(false);
                    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
                    type_object->minimal().union_type().union_flags().IS_NESTED(false);
                    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    MinimalUnionMember mst_result;
                    mst_result.common().member_id(memberId++);
                    mst_result.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_result.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_result.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_result.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_result.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_result.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_result.common().member_flags().IS_DEFAULT(false);
                    mst_result.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_OutIdentifier(false));

                    mst_result.common().label_seq().emplace_back(ReturnCode_t::RETCODE_OK);

                    MD5 result_hash("result");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_result.detail().name_hash()[i] = result_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_result);


                    // Header
                    //type_object->minimal().union_type().header().detail()... // Empty

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypeDependencies_Result", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Result", false);
                }

                const TypeObject* GetCompleteTypeLookup_getTypeDependencies_ResultObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Result", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_UNION);

                    type_object->complete().union_type().union_flags().IS_FINAL(false);
                    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
                    type_object->complete().union_type().union_flags().IS_NESTED(false);
                    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    CompleteUnionMember cst_result;
                    cst_result.common().member_id(memberId++);
                    cst_result.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_result.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_result.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_result.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_result.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_result.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_result.common().member_flags().IS_DEFAULT(false);
                    cst_result.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_OutIdentifier(true));
                    cst_result.common().label_seq().emplace_back(ReturnCode_t::RETCODE_OK);


                    cst_result.detail().name("result");

                    type_object->complete().union_type().member_seq().emplace_back(cst_result);


                    // Header
                    type_object->complete().union_type().header().detail().type_name("TypeLookup_getTypeDependencies_Result");

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_getTypeDependencies_Result", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_getTypeDependencies_Result", true);
                }



                const TypeIdentifier* GetTypeLookup_CallIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Call", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_CallObject(complete);
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Call", complete);
                }

                const TypeObject* GetTypeLookup_CallObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Call", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_CallObject();
                    }
                    // else
                    return GetMinimalTypeLookup_CallObject();
                }

                const TypeObject* GetMinimalTypeLookup_CallObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Call", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_UNION);

                    type_object->minimal().union_type().union_flags().IS_FINAL(false);
                    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
                    type_object->minimal().union_type().union_flags().IS_NESTED(false);
                    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    MinimalUnionMember mst_getTypes;
                    mst_getTypes.common().member_id(memberId++);
                    mst_getTypes.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_getTypes.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_getTypes.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_getTypes.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_getTypes.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_getTypes.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_getTypes.common().member_flags().IS_DEFAULT(false);
                    mst_getTypes.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_InIdentifier(false));

                    mst_getTypes.common().label_seq().emplace_back(TypeLookup_getTypes_HashId);

                    MD5 getTypes_hash("getTypes");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_getTypes.detail().name_hash()[i] = getTypes_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_getTypes);

                    MinimalUnionMember mst_getTypeDependencies;
                    mst_getTypeDependencies.common().member_id(memberId++);
                    mst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_getTypeDependencies.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_getTypeDependencies.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_getTypeDependencies.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_getTypeDependencies.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_getTypeDependencies.common().member_flags().IS_DEFAULT(false);
                    mst_getTypeDependencies.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_InIdentifier(false));

                    mst_getTypeDependencies.common().label_seq().emplace_back(TypeLookup_getDependencies_HashId);

                    MD5 getTypeDependencies_hash("getTypeDependencies");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_getTypeDependencies.detail().name_hash()[i] = getTypeDependencies_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_getTypeDependencies);


                    // Header
                    //type_object->minimal().union_type().header().detail()... // Empty

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Call", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Call", false);
                }

                const TypeObject* GetCompleteTypeLookup_CallObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Call", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_UNION);

                    type_object->complete().union_type().union_flags().IS_FINAL(false);
                    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
                    type_object->complete().union_type().union_flags().IS_NESTED(false);
                    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    CompleteUnionMember cst_getTypes;
                    cst_getTypes.common().member_id(memberId++);
                    cst_getTypes.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_getTypes.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_getTypes.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_getTypes.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_getTypes.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_getTypes.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_getTypes.common().member_flags().IS_DEFAULT(false);
                    cst_getTypes.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_InIdentifier(true));
                    cst_getTypes.common().label_seq().emplace_back(TypeLookup_getTypes_HashId);


                    cst_getTypes.detail().name("getTypes");

                    type_object->complete().union_type().member_seq().emplace_back(cst_getTypes);

                    CompleteUnionMember cst_getTypeDependencies;
                    cst_getTypeDependencies.common().member_id(memberId++);
                    cst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_getTypeDependencies.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_getTypeDependencies.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_getTypeDependencies.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_getTypeDependencies.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_getTypeDependencies.common().member_flags().IS_DEFAULT(false);
                    cst_getTypeDependencies.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_InIdentifier(true));
                    cst_getTypeDependencies.common().label_seq().emplace_back(TypeLookup_getDependencies_HashId);


                    cst_getTypeDependencies.detail().name("getTypeDependencies");

                    type_object->complete().union_type().member_seq().emplace_back(cst_getTypeDependencies);


                    // Header
                    type_object->complete().union_type().header().detail().type_name("TypeLookup_Call");

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Call", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Call", true);
                }



                const TypeIdentifier* GetTypeLookup_RequestIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Request", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_RequestObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Request", complete);
                }

                const TypeObject* GetTypeLookup_RequestObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Request", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_RequestObject();
                    }
                    //else
                    return GetMinimalTypeLookup_RequestObject();
                }

                const TypeObject* GetMinimalTypeLookup_RequestObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Request", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_header;
                    mst_header.common().member_id(memberId++);
                    mst_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_header.common().member_flags().IS_OPTIONAL(false);
                    mst_header.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_header.common().member_flags().IS_KEY(false);
                    mst_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_header.common().member_type_id(*eprosima::fastdds::dds::rpc::GetRequestHeaderIdentifier(false));

                    MD5 header_hash("header");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_header.detail().name_hash()[i] = header_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_header);

                    MinimalStructMember mst_data;
                    mst_data.common().member_id(memberId++);
                    mst_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_data.common().member_flags().IS_OPTIONAL(false);
                    mst_data.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_data.common().member_flags().IS_KEY(false);
                    mst_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_data.common().member_type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_CallIdentifier(false));

                    MD5 data_hash("data");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_data.detail().name_hash()[i] = data_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_data);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Request", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Request", false);
                }

                const TypeObject* GetCompleteTypeLookup_RequestObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Request", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_header;
                    cst_header.common().member_id(memberId++);
                    cst_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_header.common().member_flags().IS_OPTIONAL(false);
                    cst_header.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_header.common().member_flags().IS_KEY(false);
                    cst_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_header.common().member_type_id(*eprosima::fastdds::dds::rpc::GetRequestHeaderIdentifier(true));

                    cst_header.detail().name("header");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_header);

                    CompleteStructMember cst_data;
                    cst_data.common().member_id(memberId++);
                    cst_data.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_data.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_data.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_data.common().member_flags().IS_OPTIONAL(false);
                    cst_data.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_data.common().member_flags().IS_KEY(false);
                    cst_data.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_data.common().member_type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_CallIdentifier(true));

                    cst_data.detail().name("data");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_data);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("TypeLookup_Request");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Request", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Request", true);
                }



                const TypeIdentifier* GetTypeLookup_ReturnIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Return", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_ReturnObject(complete);
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Return", complete);
                }

                const TypeObject* GetTypeLookup_ReturnObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Return", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_ReturnObject();
                    }
                    // else
                    return GetMinimalTypeLookup_ReturnObject();
                }

                const TypeObject* GetMinimalTypeLookup_ReturnObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Return", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_UNION);

                    type_object->minimal().union_type().union_flags().IS_FINAL(false);
                    type_object->minimal().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->minimal().union_type().union_flags().IS_MUTABLE(false);
                    type_object->minimal().union_type().union_flags().IS_NESTED(false);
                    type_object->minimal().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->minimal().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->minimal().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    MinimalUnionMember mst_getType;
                    mst_getType.common().member_id(memberId++);
                    mst_getType.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_getType.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_getType.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_getType.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_getType.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_getType.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_getType.common().member_flags().IS_DEFAULT(false);
                    mst_getType.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_ResultIdentifier(false));

                    mst_getType.common().label_seq().emplace_back(TypeLookup_getTypes_HashId);

                    MD5 getType_hash("getType");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_getType.detail().name_hash()[i] = getType_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_getType);

                    MinimalUnionMember mst_getTypeDependencies;
                    mst_getTypeDependencies.common().member_id(memberId++);
                    mst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_getTypeDependencies.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_getTypeDependencies.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    mst_getTypeDependencies.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    mst_getTypeDependencies.common().member_flags().IS_KEY(false); // Doesn't apply
                    mst_getTypeDependencies.common().member_flags().IS_DEFAULT(false);
                    mst_getTypeDependencies.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_ResultIdentifier(false));

                    mst_getTypeDependencies.common().label_seq().emplace_back(TypeLookup_getDependencies_HashId);

                    MD5 getTypeDependencies_hash("getTypeDependencies");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_getTypeDependencies.detail().name_hash()[i] = getTypeDependencies_hash.digest[i];
                    }
                    type_object->minimal().union_type().member_seq().emplace_back(mst_getTypeDependencies);


                    // Header
                    //type_object->minimal().union_type().header().detail()... // Empty

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Return", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Return", false);
                }

                const TypeObject* GetCompleteTypeLookup_ReturnObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Return", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_UNION);

                    type_object->complete().union_type().union_flags().IS_FINAL(false);
                    type_object->complete().union_type().union_flags().IS_APPENDABLE(false);
                    type_object->complete().union_type().union_flags().IS_MUTABLE(false);
                    type_object->complete().union_type().union_flags().IS_NESTED(false);
                    type_object->complete().union_type().union_flags().IS_AUTOID_HASH(false); // Unsupported

                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_EXTERNAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    type_object->complete().union_type().discriminator().common().member_flags().IS_KEY(false); // Unsupported
                    type_object->complete().union_type().discriminator().common().member_flags().IS_DEFAULT(false); // Doesn't apply

                    type_object->complete().union_type().discriminator().common().type_id(*TypeObjectFactory::get_instance()->get_type_identifier("int32_t", false));

                    MemberId memberId = 0;
                    CompleteUnionMember cst_getType;
                    cst_getType.common().member_id(memberId++);
                    cst_getType.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_getType.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_getType.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_getType.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_getType.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_getType.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_getType.common().member_flags().IS_DEFAULT(false);
                    cst_getType.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypes_ResultIdentifier(true));
                    cst_getType.common().label_seq().emplace_back(TypeLookup_getTypes_HashId);


                    cst_getType.detail().name("getType");

                    type_object->complete().union_type().member_seq().emplace_back(cst_getType);

                    CompleteUnionMember cst_getTypeDependencies;
                    cst_getTypeDependencies.common().member_id(memberId++);
                    cst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_getTypeDependencies.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_getTypeDependencies.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_getTypeDependencies.common().member_flags().IS_OPTIONAL(false); // Doesn't apply
                    cst_getTypeDependencies.common().member_flags().IS_MUST_UNDERSTAND(false); // Doesn't apply
                    cst_getTypeDependencies.common().member_flags().IS_KEY(false); // Doesn't apply
                    cst_getTypeDependencies.common().member_flags().IS_DEFAULT(false);
                    cst_getTypeDependencies.common().type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_getTypeDependencies_ResultIdentifier(true));
                    cst_getTypeDependencies.common().label_seq().emplace_back(TypeLookup_getDependencies_HashId);


                    cst_getTypeDependencies.detail().name("getTypeDependencies");

                    type_object->complete().union_type().member_seq().emplace_back(cst_getTypeDependencies);


                    // Header
                    type_object->complete().union_type().header().detail().type_name("TypeLookup_Return");

                    TypeIdentifier* identifier = new TypeIdentifier();
                    identifier->_d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().union_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier->equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Return", identifier, type_object);
                    delete type_object;
                    delete identifier;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Return", true);
                }



                const TypeIdentifier* GetTypeLookup_ReplyIdentifier(bool complete)
                {
                    const TypeIdentifier * c_identifier = TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Reply", complete);
                    if (c_identifier != nullptr && (!complete || c_identifier->_d() == EK_COMPLETE))
                    {
                        return c_identifier;
                    }

                    GetTypeLookup_ReplyObject(complete); // Generated inside
                    return TypeObjectFactory::get_instance()->get_type_identifier("TypeLookup_Reply", complete);
                }

                const TypeObject* GetTypeLookup_ReplyObject(bool complete)
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Reply", complete);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }
                    else if (complete)
                    {
                        return GetCompleteTypeLookup_ReplyObject();
                    }
                    //else
                    return GetMinimalTypeLookup_ReplyObject();
                }

                const TypeObject* GetMinimalTypeLookup_ReplyObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Reply", false);
                    if (c_type_object != nullptr)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_MINIMAL);
                    type_object->minimal()._d(TK_STRUCTURE);

                    type_object->minimal().struct_type().struct_flags().IS_FINAL(false);
                    type_object->minimal().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->minimal().struct_type().struct_flags().IS_NESTED(false);
                    type_object->minimal().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    MinimalStructMember mst_header;
                    mst_header.common().member_id(memberId++);
                    mst_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_header.common().member_flags().IS_OPTIONAL(false);
                    mst_header.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_header.common().member_flags().IS_KEY(false);
                    mst_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_header.common().member_type_id(*eprosima::fastdds::dds::rpc::GetReplyHeaderIdentifier(false));

                    MD5 header_hash("header");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_header.detail().name_hash()[i] = header_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_header);

                    MinimalStructMember mst_return_value;
                    mst_return_value.common().member_id(memberId++);
                    mst_return_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    mst_return_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    mst_return_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    mst_return_value.common().member_flags().IS_OPTIONAL(false);
                    mst_return_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                    mst_return_value.common().member_flags().IS_KEY(false);
                    mst_return_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    mst_return_value.common().member_type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_ReturnIdentifier(false));

                    MD5 return_value_hash("return_value");
                    for(int i = 0; i < 4; ++i)
                    {
                        mst_return_value.detail().name_hash()[i] = return_value_hash.digest[i];
                    }
                    type_object->minimal().struct_type().member_seq().emplace_back(mst_return_value);


                    // Header
                    // TODO Inheritance
                    //type_object->minimal().struct_type().header().base_type()._d(EK_MINIMAL);
                    //type_object->minimal().struct_type().header().base_type().equivalence_hash()[0..13];
                    TypeIdentifier identifier;
                    identifier._d(EK_MINIMAL);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->minimal().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Reply", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Reply", false);
                }

                const TypeObject* GetCompleteTypeLookup_ReplyObject()
                {
                    const TypeObject* c_type_object = TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Reply", true);
                    if (c_type_object != nullptr && c_type_object->_d() == EK_COMPLETE)
                    {
                        return c_type_object;
                    }

                    TypeObject *type_object = new TypeObject();
                    type_object->_d(EK_COMPLETE);
                    type_object->complete()._d(TK_STRUCTURE);

                    type_object->complete().struct_type().struct_flags().IS_FINAL(false);
                    type_object->complete().struct_type().struct_flags().IS_APPENDABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_MUTABLE(false);
                    type_object->complete().struct_type().struct_flags().IS_NESTED(false);
                    type_object->complete().struct_type().struct_flags().IS_AUTOID_HASH(false); // Unsupported

                    MemberId memberId = 0;
                    CompleteStructMember cst_header;
                    cst_header.common().member_id(memberId++);
                    cst_header.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_header.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_header.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_header.common().member_flags().IS_OPTIONAL(false);
                    cst_header.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_header.common().member_flags().IS_KEY(false);
                    cst_header.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_header.common().member_type_id(*eprosima::fastdds::dds::rpc::GetReplyHeaderIdentifier(true));

                    cst_header.detail().name("header");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_header);

                    CompleteStructMember cst_return_value;
                    cst_return_value.common().member_id(memberId++);
                    cst_return_value.common().member_flags().TRY_CONSTRUCT1(false); // Unsupported
                    cst_return_value.common().member_flags().TRY_CONSTRUCT2(false); // Unsupported
                    cst_return_value.common().member_flags().IS_EXTERNAL(false); // Unsupported
                    cst_return_value.common().member_flags().IS_OPTIONAL(false);
                    cst_return_value.common().member_flags().IS_MUST_UNDERSTAND(false);
                    cst_return_value.common().member_flags().IS_KEY(false);
                    cst_return_value.common().member_flags().IS_DEFAULT(false); // Doesn't apply
                    cst_return_value.common().member_type_id(*eprosima::fastdds::dds::builtin::GetTypeLookup_ReturnIdentifier(true));

                    cst_return_value.detail().name("return_value");

                    type_object->complete().struct_type().member_seq().emplace_back(cst_return_value);


                    // Header
                    type_object->complete().struct_type().header().detail().type_name("TypeLookup_Reply");
                    // TODO inheritance
                    TypeIdentifier identifier;
                    identifier._d(EK_COMPLETE);

                    eprosima::fastcdr::CdrSizeCalculator calculator(eprosima::fastcdr::CdrVersion::XCDRv1);
                    size_t current_alignment {0};
                    SerializedPayload_t payload(static_cast<uint32_t>(
                        calculator.calculate_serialized_size(type_object->complete().struct_type(), current_alignment) + 4));
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, payload.max_size);
                    // Fixed endian (Page 221, EquivalenceHash definition of Extensible and Dynamic Topic Types for DDS document)
                    eprosima::fastcdr::Cdr ser(
                        fastbuffer, eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                        eprosima::fastcdr::CdrVersion::XCDRv1); // Object that serializes the data.
                    payload.encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    ser << *type_object;
                    payload.length = (uint32_t)ser.get_serialized_data_length(); //Get the serialized length
                    MD5 objectHash;
                    objectHash.update((char*)payload.data, payload.length);
                    objectHash.finalize();
                    for(int i = 0; i < 14; ++i)
                    {
                        identifier.equivalence_hash()[i] = objectHash.digest[i];
                    }

                    TypeObjectFactory::get_instance()->add_type_object("TypeLookup_Reply", &identifier, type_object);
                    delete type_object;
                    return TypeObjectFactory::get_instance()->get_type_object("TypeLookup_Reply", true);
                }

            } // namespace builtin
        } // namespace dds
    } // namespace fastdds
} // namespace eprosima